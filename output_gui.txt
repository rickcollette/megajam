
/home/megalith/megajam/gui/mixer.go:
```go
package gui

import (
	"log"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/widget"
	"megajam/knobs"
)

// CreateMixerSection creates the mixer interface with sliders and knobs.
func CreateMixerSection() *fyne.Container {
	// Crossfader slider
	crossfader := widget.NewSlider(0, 100)
	crossfader.SetValue(50)
	crossfader.OnChanged = func(value float64) {
		log.Printf("Crossfader value changed to: %.1f", value)
		// Implement crossfader functionality here
	}

	// EQ Knobs with handlers
	lowKnob := knobs.CreateKnobWithLabel("Low", -10, 10, func(value float64) {
		log.Printf("Low EQ changed to: %.1f", value)
		// Implement low EQ adjustment here
	})
	midKnob := knobs.CreateKnobWithLabel("Mid", -10, 10, func(value float64) {
		log.Printf("Mid EQ changed to: %.1f", value)
		// Implement mid EQ adjustment here
	})
	highKnob := knobs.CreateKnobWithLabel("High", -10, 10, func(value float64) {
		log.Printf("High EQ changed to: %.1f", value)
		// Implement high EQ adjustment here
	})
	volumeKnob := knobs.CreateKnobWithLabel("Volume", 0, 100, func(value float64) {
		log.Printf("Volume changed to: %.1f", value)
		// Implement volume adjustment here
	})
	balanceKnob := knobs.CreateKnobWithLabel("Balance", -50, 50, func(value float64) {
		log.Printf("Balance changed to: %.1f", value)
		// Implement balance adjustment here
	})

	return container.NewVBox(
		widget.NewLabelWithStyle("Mixer", fyne.TextAlignCenter, fyne.TextStyle{Bold: true}),
		container.NewHBox(lowKnob, midKnob, highKnob),    // EQ knobs
		container.NewHBox(volumeKnob, balanceKnob),      // Volume and balance
		container.NewVBox(widget.NewLabel("Crossfader"), crossfader), // Crossfader
	)
}

```
---

/home/megalith/megajam/gui/browser.go:
```go
package gui

import (
    "bytes"
    "fmt"
    "image"
    "log"
    "os"
    "strings"
    "sync"

    "megajam/playlist"

    "fyne.io/fyne/v2"
    "fyne.io/fyne/v2/canvas"
    "fyne.io/fyne/v2/container"
    "fyne.io/fyne/v2/dialog"
    "fyne.io/fyne/v2/widget"
    "github.com/dhowden/tag"
    "github.com/gopxl/beep/v2/mp3"
)

// ExtractAlbumArt extracts album art from an MP3 file.
func ExtractAlbumArt(filePath string) *canvas.Image {
    f, err := os.Open(filePath)
    if err != nil {
        log.Printf("Error opening file %s: %v", filePath, err)
        return nil
    }
    defer f.Close()

    meta, err := tag.ReadFrom(f)
    if err != nil {
        log.Printf("Error reading tags from file %s: %v", filePath, err)
        return nil
    }

    picture := meta.Picture()
    if picture == nil {
        log.Printf("No album art found in file %s", filePath)
        return nil
    }

    img, _, err := image.Decode(bytes.NewReader(picture.Data))
    if err != nil {
        log.Printf("Error decoding album art from file %s: %v", filePath, err)
        return nil
    }

    canvasImage := canvas.NewImageFromImage(img)
    canvasImage.SetMinSize(fyne.NewSize(100, 100)) // Set a fixed size for thumbnails
    return canvasImage
}

// ExtractMetadata extracts metadata (Title, Artist, Length) from an MP3 file.
func ExtractMetadata(filePath string) (title, artist, length string) {
    f, err := os.Open(filePath)
    if err != nil {
        log.Printf("Error opening file %s: %v", filePath, err)
        return "Unknown", "Unknown", "Unknown"
    }
    defer f.Close()

    meta, err := tag.ReadFrom(f)
    if err != nil {
        log.Printf("Error reading tags from file %s: %v", filePath, err)
        return "Unknown", "Unknown", "Unknown"
    }

    title = meta.Title()
    if title == "" {
        title = "Unknown"
    }

    artist = meta.Artist()
    if artist == "" {
        artist = "Unknown"
    }

    // Attempt to get track length using Beep's mp3 decoder
    streamer, format, err := mp3.Decode(f)
    if err != nil {
        log.Printf("Error decoding MP3 for length extraction %s: %v", filePath, err)
        length = "Unknown"
    } else {
        defer streamer.Close()
        totalSamples := streamer.Len()
        if totalSamples == -1 {
            length = "Unknown"
        } else {
            duration := float64(totalSamples) / float64(format.SampleRate)
            minutes := int(duration) / 60
            seconds := int(duration) % 60
            length = fmt.Sprintf("%d:%02d", minutes, seconds)
        }
    }

    return title, artist, length
}

// createEnhancedBrowserSection creates the playlist browser with enhanced features.
// It returns the container and a channel to send the selected track index.
func createEnhancedBrowserSection(playlist *playlist.Playlist, addTrackButton, removeTrackButton *widget.Button, myApp fyne.App, myWindow fyne.Window) (*fyne.Container, chan int) {
    // Sidebar navigation
    sidebar := container.NewVBox(
        widget.NewButton("Deezer", func() {
            dialog.ShowInformation("Info", "Deezer integration coming soon!", myWindow)
        }),
        widget.NewButton("TIDAL", func() {
            dialog.ShowInformation("Info", "TIDAL integration coming soon!", myWindow)
        }),
        widget.NewButton("Beatport", func() {
            dialog.ShowInformation("Info", "Beatport integration coming soon!", myWindow)
        }),
        widget.NewButton("SoundCloud", func() {
            dialog.ShowInformation("Info", "SoundCloud integration coming soon!", myWindow)
        }),
        widget.NewButton("Offline Cache", func() {
            dialog.ShowInformation("Info", "Offline Cache feature coming soon!", myWindow)
        }),
    )

    // Search bar
    searchEntry := widget.NewEntry()
    searchEntry.SetPlaceHolder("Search...")
    var filteredTracks []string
    var mutex sync.Mutex

    selectedTrackChan := make(chan int)

    updateFilteredTracks := func(query string) {
        mutex.Lock()
        defer mutex.Unlock()
        filteredTracks = []string{}
        for _, track := range playlist.Tracks {
            title, artist, _ := ExtractMetadata(track)
            if strings.Contains(strings.ToLower(title), strings.ToLower(query)) ||
                strings.Contains(strings.ToLower(artist), strings.ToLower(query)) {
                filteredTracks = append(filteredTracks, track)
            }
        }
        trackList.Refresh()
    }

    searchEntry.OnChanged = updateFilteredTracks

    // Thumbnail generation (asynchronous)
    thumbnailContainer := container.NewHBox()
    var wg sync.WaitGroup
    for _, trackPath := range playlist.Tracks {
        wg.Add(1)
        go func(tp string) {
            defer wg.Done()
            thumbnail := ExtractAlbumArt(tp)
            if thumbnail != nil {
                myApp.QueueUpdate(func() {
                    thumbnailContainer.Add(thumbnail)
                    thumbnailContainer.Refresh()
                })
            }
        }(trackPath)
    }
    wg.Wait()
    thumbnailScroll := container.NewHScroll(thumbnailContainer)

    // Column headers
    columnHeaders := container.NewGridWithColumns(3,
        widget.NewLabelWithStyle("Title", fyne.TextAlignLeading, fyne.TextStyle{Bold: true}),
        widget.NewLabelWithStyle("Artist", fyne.TextAlignLeading, fyne.TextStyle{Bold: true}),
        widget.NewLabelWithStyle("Length", fyne.TextAlignLeading, fyne.TextStyle{Bold: true}),
    )

    // Track list with metadata using widget.List for selection
    var selectedTrackIndex int = -1
    trackList := widget.NewList(
        func() int {
            mutex.Lock()
            defer mutex.Unlock()
            if len(filteredTracks) > 0 {
                return len(filteredTracks)
            }
            return len(playlist.Tracks)
        },
        func() fyne.CanvasObject {
            return container.NewHBox(
                widget.NewLabel("Title"),
                widget.NewLabel("Artist"),
                widget.NewLabel("Length"),
            )
        },
        func(i widget.ListItemID, o fyne.CanvasObject) {
            mutex.Lock()
            defer mutex.Unlock()
            var trackPath string
            if len(filteredTracks) > 0 {
                trackPath = filteredTracks[i]
            } else {
                trackPath = playlist.Tracks[i]
            }
            title, artist, length := ExtractMetadata(trackPath)
            labels := o.(*fyne.Container).Objects
            labels[0].(*widget.Label).SetText(title)
            labels[1].(*widget.Label).SetText(artist)
            labels[2].(*widget.Label).SetText(length)
        },
    )

    trackList.OnSelected = func(id widget.ListItemID) {
        mutex.Lock()
        defer mutex.Unlock()
        if len(filteredTracks) > 0 {
            selectedTrackIndex = findIndex(playlist.Tracks, filteredTracks[id])
        } else {
            selectedTrackIndex = id
        }
        log.Printf("Selected track index: %d", selectedTrackIndex)
        selectedTrackChan <- selectedTrackIndex
    }

    // Helper function to find the index of a track in the main playlist
    findIndex := func(tracks []string, target string) int {
        for i, track := range tracks {
            if track == target {
                return i
            }
        }
        return -1
    }

    // Assemble browser layout
    return container.NewBorder(
        container.NewVBox(searchEntry, thumbnailScroll, columnHeaders), // Top: Search, thumbnails, and column headers
        container.NewHBox(addTrackButton, removeTrackButton),           // Bottom: Add/Remove buttons
        sidebar,                                                        // Left: Sidebar
        nil,                                                            // Right: None
        trackList,                                                      // Center: Track list
    ), selectedTrackChan
}

```
---

/home/megalith/megajam/gui/themes.go:
```go
package gui

import (
	"image/color"
	"log"

	"megajam/config"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/theme"
)

// CustomTheme implements fyne.Theme based on user configuration.
type CustomTheme struct {
	config *config.ThemeConfig
}

// Ensure CustomTheme implements fyne.Theme.
var _ fyne.Theme = (*CustomTheme)(nil)

// NewCustomTheme creates a new CustomTheme with the given ThemeConfig.
func NewCustomTheme(config *config.ThemeConfig) *CustomTheme {
	return &CustomTheme{config: config}
}

// Color returns the color for the given name and variant.
func (t *CustomTheme) Color(name fyne.ThemeColorName, variant fyne.ThemeVariant) color.Color {
	switch name {
	case theme.ColorNameBackground:
		c, err := config.ParseHexColor(t.config.BackgroundColor)
		if err != nil {
			log.Printf("Error parsing BackgroundColor: %v", err)
			return theme.DefaultTheme().Color(name, variant)
		}
		return c
	case theme.ColorNameButton:
		c, err := config.ParseHexColor(t.config.ButtonColor)
		if err != nil {
			log.Printf("Error parsing ButtonColor: %v", err)
			return theme.DefaultTheme().Color(name, variant)
		}
		return c
	case theme.ColorNameDisabledButton:
		return color.NRGBA{R: 51, G: 51, B: 51, A: 255} // #333333
	case theme.ColorNamePrimary:
		c, err := config.ParseHexColor(t.config.HighlightColor)
		if err != nil {
			log.Printf("Error parsing HighlightColor: %v", err)
			return theme.DefaultTheme().Color(name, variant)
		}
		return c
	case theme.ColorNameForeground:
		c, err := config.ParseHexColor(t.config.TextColor)
		if err != nil {
			log.Printf("Error parsing TextColor: %v", err)
			return theme.DefaultTheme().Color(name, variant)
		}
		return c
	default:
		return theme.DefaultTheme().Color(name, variant)
	}
}

// Icon returns the icon for the given name.
func (t *CustomTheme) Icon(name fyne.ThemeIconName) fyne.Resource {
	return theme.DefaultTheme().Icon(name)
}

// Font returns the font for the given text style.
func (t *CustomTheme) Font(style fyne.TextStyle) fyne.Resource {
	return theme.DefaultTheme().Font(style)
}

// Size returns the size for the given size name.
func (t *CustomTheme) Size(name fyne.ThemeSizeName) float32 {
	return theme.DefaultTheme().Size(name)
}

```
---

/home/megalith/megajam/gui/deck.go:
```go
package gui

import (
    "image/color"
    "log"

    "fyne.io/fyne/v2"
    "fyne.io/fyne/v2/canvas"
    "fyne.io/fyne/v2/container"
    "fyne.io/fyne/v2/widget"
)

// CreateDeckSection creates the deck interface with play/pause, sync, pitch control, and pads.
func CreateDeckSection(deckName, songTitle, timeLeft, bpm string, mp3Image *canvas.Image, playPauseHandler func(), syncHandler func(), pitchHandler func(float64)) *fyne.Container {
    // Sync Button
    syncButton := widget.NewButton("Sync", func() {
        if syncHandler != nil {
            syncHandler()
        } else {
            log.Println("Sync handler not implemented")
        }
    })

    // Circular Display
    titleLabel := widget.NewLabelWithStyle(songTitle, fyne.TextAlignCenter, fyne.TextStyle{Bold: true})
    timeLabel := widget.NewLabel(timeLeft)
    bpmLabel := widget.NewLabel("BPM: " + bpm)

    if mp3Image == nil {
        // Provide a default image if none is supplied
        // You need to provide a default.png resource or handle it accordingly
        mp3Image = canvas.NewImageFromResource(fyne.NewStaticResource("default.png", nil))
        mp3Image.FillMode = canvas.ImageFillContain
        mp3Image.SetMinSize(fyne.NewSize(100, 100))
    }

    mainDisplay := container.NewVBox(
        mp3Image,
        titleLabel,
        timeLabel,
        bpmLabel,
    )
    mainDisplayContainer := container.NewMax(
        canvas.NewCircle(color.Black), // Circular background
        mainDisplay,
    )

    // Pitch Control Slider
    pitchSlider := widget.NewSlider(-10, 10) // Adjust range as needed
    pitchSlider.Orientation = widget.Vertical
    pitchSlider.OnChanged = pitchHandler
    pitchControl := container.NewVBox(
        widget.NewLabelWithStyle("Pitch Control", fyne.TextAlignCenter, fyne.TextStyle{}),
        pitchSlider,
    )

    // Play/Pause Button
    playPauseButton := widget.NewButton("Play", func() {
        if playPauseHandler != nil {
            playPauseHandler()
        } else {
            log.Println("Play/Pause handler not implemented")
        }
    })

    // Pads
    pads := container.NewGridWithColumns(4,
        widget.NewButton("Pad 1", func() { log.Println("Pad 1 pressed") }),
        widget.NewButton("Pad 2", func() { log.Println("Pad 2 pressed") }),
        widget.NewButton("Pad 3", func() { log.Println("Pad 3 pressed") }),
        widget.NewButton("Pad 4", func() { log.Println("Pad 4 pressed") }),
        widget.NewButton("Pad 5", func() { log.Println("Pad 5 pressed") }),
        widget.NewButton("Pad 6", func() { log.Println("Pad 6 pressed") }),
        widget.NewButton("Pad 7", func() { log.Println("Pad 7 pressed") }),
        widget.NewButton("Pad 8", func() { log.Println("Pad 8 pressed") }),
    )

    // Assemble Deck Layout
    return container.NewVBox(
        widget.NewLabelWithStyle(deckName, fyne.TextAlignCenter, fyne.TextStyle{Bold: true}),
        container.NewHBox(syncButton, widget.NewLabel("")),    // Sync button
        container.NewHBox(mainDisplayContainer, pitchControl), // Main Display and Pitch Control
        playPauseButton,                                       // Play/Pause button
        container.NewVBox(widget.NewLabel("PADS"), pads),      // Pads section
    )
}

```
---

/home/megalith/megajam/gui/gui.go:
```go
package gui

import (
    "log"

    "megajam/config"
    "megajam/playlist"
    "megajam/player"

    "fyne.io/fyne/v2"
    "fyne.io/fyne/v2/app"
    "fyne.io/fyne/v2/container"
    "fyne.io/fyne/v2/dialog"
    "fyne.io/fyne/v2/widget"
)

func CreateGUI() {
    // Initialize Fyne app
    myApp := app.NewWithID("com.example.megajam")
    myWindow := myApp.NewWindow("Megajam DJ Controller")

    // Load configuration
    appConfig, err := config.LoadConfig("config/config.json")
    if err != nil {
        dialog.ShowError(err, myWindow)
        myWindow.ShowAndRun()
        return
    }

    // Validate configuration
    err = config.ValidateConfig(appConfig)
    if err != nil {
        dialog.ShowError(err, myWindow)
        myWindow.ShowAndRun()
        return
    }

    // Apply custom theme
    myApp.Settings().SetTheme(NewCustomTheme(&appConfig.Theme))

    // Resize window based on configuration
    myWindow.Resize(fyne.NewSize(
        float32(appConfig.Layout.WindowWidth),
        float32(appConfig.Layout.WindowHeight),
    ))

    // Initialize player with a default track
    mp3Player, err := player.NewMP3Player("path/to/default.mp3") // Replace with actual default track path
    if err != nil {
        dialog.ShowError(err, myWindow)
    }
    defer mp3Player.Close()

    // Initialize sections with handlers
    leftDeck := CreateDeckSection(
        "Left Deck",
        "Track A",
        "3:45",
        "120",
        nil, // mp3Image can be set dynamically
        func() {
            if mp3Player.Paused() {
                mp3Player.Play()
                // Update button text to "Pause" (Requires access to the button)
                log.Println("Left Deck: Play")
            } else {
                mp3Player.Pause()
                // Update button text to "Play" (Requires access to the button)
                log.Println("Left Deck: Pause")
            }
        },
        func() {
            log.Println("Left Deck: Sync button clicked")
            // Implement sync functionality here
        },
        func(value float64) {
            mp3Player.SetVolume(value / 100) // Assuming volume range is 0-100
            log.Printf("Left Deck: Volume set to %.1f%%", value)
        },
    )

    rightDeck := CreateDeckSection(
        "Right Deck",
        "Track B",
        "4:10",
        "126",
        nil, // mp3Image can be set dynamically
        func() {
            if mp3Player.Paused() {
                mp3Player.Play()
                // Update button text to "Pause" (Requires access to the button)
                log.Println("Right Deck: Play")
            } else {
                mp3Player.Pause()
                // Update button text to "Play" (Requires access to the button)
                log.Println("Right Deck: Pause")
            }
        },
        func() {
            log.Println("Right Deck: Sync button clicked")
            // Implement sync functionality here
        },
        func(value float64) {
            mp3Player.SetVolume(value / 100) // Assuming volume range is 0-100
            log.Printf("Right Deck: Volume set to %.1f%%", value)
        },
    )

    mixer := CreateMixerSection()

    // Initialize playlist browser
    currentPlaylist := playlist.NewPlaylist("New Playlist")
    addTrackButton := widget.NewButton("Add Track", func() {
        dialog.ShowFileOpen(func(uri fyne.URIReadCloser, err error) {
            if err != nil {
                dialog.ShowError(err, myWindow)
                return
            }
            if uri == nil {
                return
            }
            err = currentPlaylist.AddTrack(uri.URI().Path())
            if err != nil {
                dialog.ShowError(err, myWindow)
                return
            }
            dialog.ShowInformation("Success", "Track added to playlist!", myWindow)
            // Refresh the browser section if necessary
            // Implement a way to refresh thumbnails and track list
        }, myWindow)
    })
    removeTrackButton := widget.NewButton("Remove Track", func() {
        // Implement track removal logic using selectedTrackIndex
        // This requires accessing the selectedTrackIndex received from the channel
        // We'll set up a goroutine to listen to the channel
    })
    browserSection, selectedTrackChan := createEnhancedBrowserSection(currentPlaylist, addTrackButton, removeTrackButton, myApp, myWindow)

    // Handle Remove Track Button Click
    removeTrackButton.OnTapped = func() {
        selectedIndex := -1
        select {
        case idx := <-selectedTrackChan:
            selectedIndex = idx
        default:
            // No selection made
        }

        if selectedIndex >= 0 {
            err := currentPlaylist.RemoveTrack(selectedIndex)
            if err != nil {
                dialog.ShowError(err, myWindow)
                return
            }
            dialog.ShowInformation("Success", "Track removed from playlist!", myWindow)
            log.Printf("Track at index %d removed from playlist", selectedIndex)
            // Optionally, refresh the browser section
            browserSection.Refresh()
        } else {
            dialog.ShowInformation("Info", "No track selected to remove.", myWindow)
        }
    }

    // Layout components
    mainLayout := container.NewBorder(
        nil,                    // Top
        browserSection,         // Bottom
        nil,                    // Left
        nil,                    // Right
        container.NewHBox(leftDeck, mixer, rightDeck), // Center: Decks and mixer
    )

    // Set and show window content
    myWindow.SetContent(mainLayout)
    myWindow.ShowAndRun()
}

```
---
